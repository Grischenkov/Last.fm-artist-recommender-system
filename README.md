# Last.fm-artist-recommender-system

## Задание
*Цель:* разработать консольное приложение для поиска похожих музыкальных исполнителей

*Датасет:* https://www.kaggle.com/datasets/pcbreviglieri/lastfm-music-artist-scrobbles

## Инструкия по запуску
+ Docker
```sh
git clone https://github.com/Grischenkov/Last.fm-artist-recommender-system.git
cd Last.fm-artist-recommender-system
docker build -t artist-recommender-system .
docker run -it artist-recommender-system /bin/bash
python main.py
```
+ Python 3.10.10
```sh
git clone https://github.com/Grischenkov/Last.fm-artist-recommender-system.git
cd Last.fm-artist-recommender-system
pip install -r requirements.txt
python main.py
```

## Примеры работы
> Имя исполнителя: Rihanna
Похожие: Beyonce, Britney Spears, Kat Deluna, Christina Aguilera, Black Eyed Peas

> Имя исполнителя: 50 Cent
Похожие: G-Unit, Nate Dogg, Dj Whoo Kid, Donguralesko & Dj Kostek, Rychu Peja Solufka

> Имя исполнителя: Metallica
Похожие: Tsjuder, Opera Ix, Darkened Nocturn Slaughtercult, Grand Belial's Key, Limbonic Art


## EDA
Код представлен в ноутбуке ['data/EDA.ipynb'](https://github.com/Grischenkov/Last.fm-artist-recommender-system/blob/main/data/EDA.ipynb).

+ Данные об исполнителях:
    + Имеем информацию о 17493 исполнителях.
    + Столбцы:
        + artist_id
        + artist_name
    + Пропуски в данных отсутствуют.
    + Есть одно повторяющееся имя исполнителя с разными id. 
    Удалять не будем, так как может существовать несколько исполнителей с одним названием.

+ Данные о прослушиваниях
    + Имеем 92723 записей.
    + Столбцы:
        + user_id
        + artist_id
        + scrobbles (число прослушиваний)
    + Пропуски в данных отсутствуют.
    + Есть повторяющиеся пары id пользователя и исполнителя с разным числом прослушиваний.
    Возможные варианты обработки:
        + <u>Удалить дубликаты</u>
        + Суммировать число прослушиваний
        + Усреднить значения прослушиваний
    + Большая часть пользователей имеет информацию о прослушивании 50 исполнителей, однако есть пользователи, прослушавшие меньшее количество, в том числе всего одного исполнителя.
    Удалять таких пользователей из выборки не следует, так как в этом случае информация о прослушиваниях будет не для всех исполнителей.

Для улучшения работы алгоритмов можно было бы обогатить набор данных различной дополнительной информацией об исполнителях. Например, информацией о жанре или стране.
Также по уже имеющимся данным возможно расчитать дополнительные характеристики. Например, среднее число прослушиваний для пользователя, число пользователей, прослушавших исполнителя.

## Оценка качества
При оценке качества будем отталкиваться от гипотезы о том, что пользователи слушают схожих исполнителей или несколько групп схожих исполнителей.

Пользователь прослушал n исполнителей. Тогда мы можем для каждого исполнителя, прослушанного пользователем, порекомендовать k похожих исполнителей, составить список из k*n рекомендаций пользователю и рассчитать количество совпадений. Затем поделить его на число рекомендаций.

Итоговая оценка качества для всех пользователей: среднее оценок для каждого пользователя.

При оценке не будем учитывать пользователей, прослушавших только одного исполнителя, так как для них невозможно корректно получить такую оценку.

## Методы решения
Код представлен в ноутбуке ['research/research.ipynb'](https://github.com/Grischenkov/Last.fm-artist-recommender-system/blob/main/research/research.ipynb). ВСТАВЬ ССЫЛКУ

+ BASELINE. Рекомендация самых популярных исполнителей.
Такой подход позволяет использовать минимальное количество памяти и времени на построение рекомендаций, поскольку необходимо хранить только небольшой отсортированный список самых популярных исполнителей и брать из него некоторое количество первых элементов.
+ Матрица схожести.
+ kNN. Поиск k ближайших соседей из векторов исполнителей. Классический kNN можно заменить, например, на FAISS для ускорения поиска соседей.
+ CosineRecommender библиотеки implicit.
+ ALS библиотеки implicit. Разряженная матрица взаимодействий пользователей и объектов раскладывается на две других: матрицу пользователй и матрицу объектов. При разложении исходной матрицы алгоритм поочередно фиксирует одну из матриц и оптимизирует вторую таким образом, чтобы их произведение минимально отличалось от исходной.

Результаты экспериментов:

 |                            | BASELINE | Matrix   | kNN     | CosRec   | ALS     |
 | -------------------------- | -------- | -------- | ------- | -------- | ------- |
 | Качество                   | 0.070    | 0.113    | 0.075   | 0.076    | 0.089   |
 | Время работы*, с            | 0.060    | 310.141  | 164.205 | 13.215   | 32.644  |
 | Использование памяти, байт | 2271     | 31825587 | 1183374 | 18903830 | 4963084 |
 
 *Время работы: время прогноза 5 похожих исполнителей для каждого исполнителя для всех пользователей.

 Сравнительные графики:

 ![Графики](img/charts.jpg?raw=true "Графики")

 Алгоритм ALS является предпочтительным, так как является вторым по качеству, при этом являясь намного более эффективным по времени выполнения и используемой памяти, чем алгоритм, основанный на матрице схожести, показавший наилучшую оценку качества.